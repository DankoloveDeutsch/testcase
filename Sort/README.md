# Задание №3
На языке Python или С++ предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

Если массив может быть отсортированным(в том числе и с совподающими элементами), то было бы эффективно применить устойчивую сортировку. Одной из таких является - Timsort.
У timsort сложность по времени: в лучшем случае n, в среднем и худшем - nlog(n). По памяти - n. Timsort это гибридная сортировка, суть которой заключается в нескольких пунктах:
1) Разделить входной массив на подмассивы
2) Отсортировать каждый подмассив сортировкой вставками
3) Собрать подмссивы в единый массив с помощью модиыированной сортировки слиянием.

Почему эта функция соответствует критериям задания?
 - Сортировка является устойчивой, тоесть уже отсортированные части данных не будут переставляться, что сильно экономит процессорное время.
 - Среднее время работы nlog(n), что является лучшим решением для случайных данных.

(прошлое решение)
ИЛИ
Применить сортировку, которая работает в худшем случае за nlog(n) (на больших данных, отсортированных данных, обратно отсортированных данных) поэтому я стал искать варианты гибридных сортировок на основе QuickSort, которые бы решили проблему "худшего случая" со сложностью O(n^2). Одной из таких является сортировка, которая входит в стандартную библиотеку C++ std::sort - IntroSort.

IntroSort совмещается три реализации сортировок:
- Сортировку вставками
- Быструю сортировку
- Пирамидальную сортировку

В IntroSort вводится понятие "Максимальная глубина рекурсии", она высчитывается по формуле 2log(n), где n количество элементов. 

- Сортировка вставками выполняется если размерность массива не больше 16, так как на таких малых данных она работает лучше всех остальных типов сортировок. Сложность по времени O(n). Сложность по памяти O(1).
- Быстрая сортировка работает пока не привысит максимальную глубину рекрусии. На этом участке быстрая сортировка работает в худшем случае как O(nlog(n)). 
- Далее включается пирамидальная сортировка, для которой общая сложность O(nlog(n))

Худшая сложность по времени сортировки IntroSort - O(nlog(n)). По времени - log(n)

В итоге такой гибридный алгоритм сортировки решает проблемы быстрой сортировки, когда попадается массив "Худшего случая", не давая уйти в сложность O(n^2)
